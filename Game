#include <iostream>
#include <conio.h>
#include <stdio.h>
#include <cmath>
#include <iomanip>
#include <fstream>
#include <windows.h>
#include <string>
#include <cstdlib>
#include <vector>
#include <time.h>
using namespace std;

string line;
ifstream myfile("File.txt");
bool gOver;
const int FIELD_WIDTH = 40;
const int FIELD_HEIGHT = 20;
const double ACCELERATION = 0.098;
int x, y;
int coinX, coinY;
int points = 0;
bool coin = 0;
int currentClock = 0;
int ellapsedTime = 0;
enum eDirecton { STOP = 1, LEFT, RIGHT, UP, DOWN };

eDirecton dir;

struct Obstacle {
	int coordinateX, coordinateY;
	char symbol;
	double velocity = 0;

	double calculateDistance(double t) {
		return velocity + ACCELERATION * (t * t) / 2;
	}

	double calculateVelocity(double t) {
		return velocity + ACCELERATION * t;
	}
};

struct Player {
	int coordinateX, coordinateY;
	char symbol;
};

vector<Obstacle> obstacles;
Player player;

void setPosition(short x, short y)
{
	COORD crd = { x,y };
	HANDLE hOut = ::GetStdHandle(STD_OUTPUT_HANDLE);
	if (INVALID_HANDLE_VALUE != hOut) {
		::SetConsoleCursorPosition(hOut, crd);
	}
}

void ClearScreen()
{
	//we clear the frame by resetting the cursor position
	setPosition(0, 0);
}

Obstacle GenerateObstacle() {
	int coordinateX = rand() % FIELD_WIDTH + 1;
	int coordinateY = FIELD_HEIGHT - 3;
	string symbols = "#$*@";
	//char symbols[] = {'#', '$', '*', '@'};

	int randomSymbolIndex = rand() % symbols.size();
	Obstacle obstacle;
	obstacle.coordinateX = coordinateX;
	obstacle.coordinateY = coordinateY;
	obstacle.symbol = '#';

	return obstacle;
}


void Setup() /*Values and Positions of entities*/
{
	srand(time(NULL));

	gOver = false;
	dir = STOP;

	player.coordinateX = (FIELD_WIDTH / 2) - 1;
	player.coordinateY = 1;
	player.symbol = 'O';

	obstacles.push_back(GenerateObstacle());
}


void Draw()/*Drawing the map and the Charachter and also the entities*/
{
	Obstacle velocity;
	ClearScreen();
	cout << "C0NTROLS:" << endl << "A - LEFT" << endl << "D - RIGHT " << endl;
	for (int i = 0; i < FIELD_WIDTH; i++)
		cout << "#";
	cout << endl;

	for (int i = 0; i < FIELD_HEIGHT; i++)
	{
		for (int j = 0; j < FIELD_WIDTH; j++)
		{
			if (j == 0)
			{
				cout << "#";
			}
			else if (j == FIELD_WIDTH - 1)
			{
				cout << "#";
			}
			else {
				bool hasOutput = false;
				for (auto it = obstacles.begin(); it != obstacles.end(); ++it)
				{
					if (j == (*it).coordinateX && i == (*it).coordinateY)
					{
						cout << (*it).symbol;
						hasOutput = true;
					}
				}

				if (j == player.coordinateX && i == player.coordinateY)
				{
					cout << player.symbol;
					hasOutput = true;
				}

				if (!hasOutput) {
					cout << " ";
				}
			}




		}
		cout << endl;
	}
	for (int i = 0; i < FIELD_WIDTH; i++)
	{
		cout << "#";
	}
	cout << endl;

	cout << "P0INTS: " << points << endl;

	cout << "T1ME: " << ellapsedTime<<endl;
	for (auto it = obstacles.begin(); it != obstacles.end(); ++it)
	{
		if ((*it).velocity * 100 <= 277)
		{
			cout << "Velocity: " << (*it).velocity * 100<<" m/s";

		}
		else
		{
			cout << "Velocity: " << 277 << "m/s";
		}
	}
	
	if (x >= FIELD_WIDTH)
	{
		x = FIELD_WIDTH - 1;
	}
	else if (x < 0)
	{
		x = 0;
	}
	if (y >= FIELD_HEIGHT)
	{
		y = FIELD_HEIGHT - 1;
	}
	else if (y < 0)
	{
		y = 0;
	}

}
void Input()
{
	if (_kbhit())
	{
		switch (_getch())
		{
		case 'a':
		{
			dir = LEFT;
			player.coordinateX = (player.coordinateX - 1 > 0) ? player.coordinateX - 1 : 1;
			break; }
		case 'd':
		{
			dir = RIGHT;

			player.coordinateX = (player.coordinateX + 1 < FIELD_WIDTH - 1) ? player.coordinateX + 1 : FIELD_WIDTH - 2;
			break;
		}
		case 'x':
		{
			gOver = true;
			break;
		}
		}
	}


}
void coinObt() /*Coin Obtainted*/
{
	if (x == coinX && y == coinY)
	{
		coin = 1;

	}
	if (coin == 1)
	{
		cout << " ";
		points = 1;
	}



}


void UpdateObstacles()
{
	for (auto it = obstacles.begin(); it != obstacles.end(); ++it)
	{
		(*it).coordinateY -= (int)(*it).calculateDistance(ellapsedTime);
		(*it).velocity = (*it).calculateVelocity(ellapsedTime);
	}
}

void CL0()
{
	currentClock++;
	if (currentClock % 7 == 0)
	{
		ellapsedTime++;
		if (currentClock > 0) {
			UpdateObstacles();
		}
	}
}
void Death()
{
	for (auto it = obstacles.begin(); it != obstacles.end(); ++it)
	{
		if (player.coordinateX == (*it).coordinateX && player.coordinateY == (*it).coordinateY)
		{
			gOver = true;
		}
	}

}

void GameO()/*Game Over*/
{
	if (gOver == true)
	{
		ClearScreen();
		string line;
		ifstream myfile("File.txt");
		if (myfile.is_open())
		{
			while (getline(myfile, line))
			{
				cout << line << '\n';
			}
			myfile.close();
		}
		else
		{
			cout << "Unable to open file";
		}
		cout << "F1NAL SC0RE: " << points;
	}



}

int main()
{
	Setup();
	while (gOver == false)
	{

		Draw();
		Input();
		CL0();
		coinObt();
		Death();
		//GameO();
		Sleep(100);
	}
	return 0;
}

/*OOO     OOO
   O     O
   O     O
  OOO     OOO  */
